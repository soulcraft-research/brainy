import express from 'express'
import cors from 'cors'
import { logger } from '../utils/logger.js'

/**
 * Minimal HTTP Augmentation - Lightweight REST API using Brainy's native augmentation system
 * Provides essential HTTP endpoints with zero configuration
 */
export class HttpAugmentation {
  constructor(options = {}) {\n    this.type = 'HTTP'\n    this.priority = 3 // Lower priority - fallback option\n    this.options = {\n      port: options.port || 3000,\n      enableCORS: options.enableCORS !== false,\n      enableCompression: options.enableCompression !== false,\n      minimal: options.minimal !== false, // Keep endpoints minimal\n      rateLimit: options.rateLimit || { max: 100, windowMs: 60000 },\n      ...options\n    }\n    \n    this.app = null\n    this.server = null\n    this.db = null\n  }\n\n  async augment(brainyData, context) {\n    this.db = brainyData\n    \n    try {\n      this.app = express()\n      this.setupMiddleware()\n      this.setupRoutes()\n      \n      // Start server\n      await new Promise((resolve, reject) => {\n        this.server = this.app.listen(this.options.port, (error) => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        })\n      })\n      \n      logger.info('HTTP augmentation initialized', {\n        port: this.options.port,\n        features: {\n          cors: this.options.enableCORS,\n          compression: this.options.enableCompression,\n          minimal: this.options.minimal\n        }\n      })\n      \n    } catch (error) {\n      logger.error('Failed to initialize HTTP augmentation:', error)\n      throw error\n    }\n  }\n\n  setupMiddleware() {\n    // CORS\n    if (this.options.enableCORS) {\n      this.app.use(cors({\n        origin: true,\n        credentials: false,\n        methods: ['GET', 'POST', 'PUT', 'DELETE'],\n        allowedHeaders: ['Content-Type', 'Accept']\n      }))\n    }\n    \n    // Compression\n    if (this.options.enableCompression) {\n      const compression = require('compression')\n      this.app.use(compression())\n    }\n    \n    // JSON parsing\n    this.app.use(express.json({ limit: '10mb' }))\n    \n    // Request logging\n    this.app.use((req, res, next) => {\n      const start = Date.now()\n      res.on('finish', () => {\n        const duration = Date.now() - start\n        logger.debug('HTTP Request', {\n          method: req.method,\n          path: req.path,\n          status: res.statusCode,\n          duration: `${duration}ms`\n        })\n      })\n      next()\n    })\n  }\n\n  setupRoutes() {\n    // Health check\n    this.app.get('/health', (req, res) => {\n      res.json({\n        status: 'healthy',\n        service: 'brainy-http-augmentation',\n        timestamp: new Date().toISOString(),\n        uptime: process.uptime()\n      })\n    })\n\n    // Root endpoint\n    this.app.get('/', (req, res) => {\n      res.json({\n        message: 'Brainy HTTP Augmentation',\n        version: '1.0.0',\n        endpoints: {\n          search: 'POST /search',\n          add: 'POST /add',\n          get: 'GET /entity/:id',\n          addVerb: 'POST /verb',\n          health: 'GET /health'\n        },\n        documentation: 'This is a minimal HTTP interface to Brainy. Use WebSocket or WebRTC augmentations for better performance.'\n      })\n    })\n\n    // Search entities\n    this.app.post('/search', this.asyncHandler(async (req, res) => {\n      const { query, limit = 10, threshold = 0.7, options = {} } = req.body\n      \n      if (!query || typeof query !== 'string') {\n        return res.status(400).json({\n          error: 'Query is required and must be a string'\n        })\n      }\n      \n      const results = await this.db.search(query, Math.min(limit, 100), {\n        threshold: Math.max(0, Math.min(1, threshold)),\n        includeMetadata: true,\n        ...options\n      })\n      \n      res.json({\n        success: true,\n        query,\n        results,\n        count: results.length,\n        timestamp: new Date().toISOString()\n      })\n    }))\n\n    // Add entity\n    this.app.post('/add', this.asyncHandler(async (req, res) => {\n      const { data, metadata = {}, options = {} } = req.body\n      \n      if (!data) {\n        return res.status(400).json({\n          error: 'Data is required'\n        })\n      }\n      \n      const enhancedMetadata = {\n        ...metadata,\n        source: 'http-augmentation',\n        timestamp: new Date().toISOString(),\n        userAgent: req.get('User-Agent')\n      }\n      \n      const id = await this.db.add(data, enhancedMetadata, options)\n      \n      res.status(201).json({\n        success: true,\n        id,\n        data,\n        metadata: enhancedMetadata\n      })\n    }))\n\n    // Get entity by ID\n    this.app.get('/entity/:id', this.asyncHandler(async (req, res) => {\n      const { id } = req.params\n      \n      if (!id) {\n        return res.status(400).json({\n          error: 'Entity ID is required'\n        })\n      }\n      \n      const entity = await this.db.get(id)\n      \n      if (!entity) {\n        return res.status(404).json({\n          error: `Entity with ID ${id} not found`\n        })\n      }\n      \n      res.json({\n        success: true,\n        data: entity\n      })\n    }))\n\n    // Add relationship (verb)\n    this.app.post('/verb', this.asyncHandler(async (req, res) => {\n      const { sourceId, targetId, verbType, weight, metadata = {}, options = {} } = req.body\n      \n      if (!sourceId || !targetId || !verbType) {\n        return res.status(400).json({\n          error: 'sourceId, targetId, and verbType are required'\n        })\n      }\n      \n      const enhancedMetadata = {\n        ...metadata,\n        source: 'http-augmentation',\n        timestamp: new Date().toISOString(),\n        userAgent: req.get('User-Agent')\n      }\n      \n      const verbId = await this.db.addVerb(sourceId, targetId, verbType, {\n        weight,\n        metadata: enhancedMetadata,\n        ...options\n      })\n      \n      res.status(201).json({\n        success: true,\n        id: verbId,\n        sourceId,\n        targetId,\n        verbType,\n        weight,\n        metadata: enhancedMetadata\n      })\n    }))\n\n    // Batch operations (if not minimal)\n    if (!this.options.minimal) {\n      this.app.post('/batch/add', this.asyncHandler(async (req, res) => {\n        const { items } = req.body\n        \n        if (!Array.isArray(items) || items.length === 0) {\n          return res.status(400).json({\n            error: 'Items array is required and must not be empty'\n          })\n        }\n        \n        if (items.length > 100) {\n          return res.status(400).json({\n            error: 'Maximum 100 items allowed per batch'\n          })\n        }\n        \n        const results = []\n        const timestamp = new Date().toISOString()\n        \n        for (const item of items) {\n          try {\n            const enhancedMetadata = {\n              ...item.metadata,\n              source: 'http-augmentation-batch',\n              timestamp,\n              userAgent: req.get('User-Agent')\n            }\n            \n            const id = await this.db.add(item.data, enhancedMetadata, item.options || {})\n            results.push({\n              success: true,\n              id,\n              data: item.data,\n              metadata: enhancedMetadata\n            })\n          } catch (error) {\n            results.push({\n              success: false,\n              error: error.message,\n              data: item.data\n            })\n          }\n        }\n        \n        res.json({\n          success: true,\n          results,\n          totalProcessed: results.length,\n          successful: results.filter(r => r.success).length,\n          failed: results.filter(r => !r.success).length\n        })\n      }))\n    }\n\n    // Statistics endpoint (if available)\n    this.app.get('/stats', this.asyncHandler(async (req, res) => {\n      try {\n        const stats = await this.db.getStatistics()\n        res.json({\n          success: true,\n          stats,\n          timestamp: new Date().toISOString()\n        })\n      } catch (error) {\n        res.json({\n          success: true,\n          message: 'Statistics not available',\n          reason: error.message\n        })\n      }\n    }))\n\n    // Error handler\n    this.app.use((error, req, res, next) => {\n      logger.error('HTTP augmentation error:', {\n        error: error.message,\n        stack: error.stack,\n        path: req.path,\n        method: req.method\n      })\n      \n      res.status(500).json({\n        error: 'Internal server error',\n        message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',\n        timestamp: new Date().toISOString()\n      })\n    })\n\n    // 404 handler\n    this.app.use((req, res) => {\n      res.status(404).json({\n        error: 'Endpoint not found',\n        message: `${req.method} ${req.path} is not available`,\n        availableEndpoints: [\n          'GET /',\n          'GET /health',\n          'POST /search',\n          'POST /add',\n          'GET /entity/:id',\n          'POST /verb',\n          'GET /stats'\n        ]\n      })\n    })\n  }\n\n  // Async error handler wrapper\n  asyncHandler(fn) {\n    return (req, res, next) => {\n      Promise.resolve(fn(req, res, next)).catch(next)\n    }\n  }\n\n  async cleanup() {\n    if (this.server) {\n      await new Promise((resolve) => {\n        this.server.close(resolve)\n      })\n    }\n    \n    logger.info('HTTP augmentation cleaned up')\n  }\n}