import { logger } from '../utils/logger.js'

/**
 * Adaptive Storage Augmentation - Intelligently adapts storage behavior based on usage patterns\n * Automatically optimizes storage, caching, and data management without configuration\n */\nexport class AdaptiveStorageAugmentation {\n  constructor(capabilities) {\n    this.type = 'MEMORY'\n    this.priority = 2\n    this.capabilities = capabilities\n    this.options = {\n      monitoringInterval: 60000, // 1 minute\n      adaptationThreshold: 0.8, // Adapt when metrics exceed 80% of capacity\n      cacheOptimizationInterval: 300000, // 5 minutes\n      storageOptimizationInterval: 900000, // 15 minutes\n    }\n    \n    this.db = null\n    this.metrics = {\n      memoryUsage: [],\n      storageOperations: [],\n      cacheHitRate: [],\n      queryPerformance: []\n    }\n    \n    this.monitoringTimer = null\n    this.cacheOptimizationTimer = null\n    this.storageOptimizationTimer = null\n    this.adaptations = []\n  }\n\n  async augment(brainyData, context) {\n    this.db = brainyData\n    \n    try {\n      // Start monitoring\n      this.startMonitoring()\n      \n      // Start optimization timers\n      this.startOptimizations()\n      \n      logger.info('Adaptive Storage augmentation initialized', {\n        capabilities: {\n          memory: `${this.capabilities.memory.available}MB`,\n          storage: Object.keys(this.capabilities.storage).filter(k => this.capabilities.storage[k]),\n          environment: this.capabilities.environment\n        },\n        monitoring: {\n          interval: this.options.monitoringInterval,\n          adaptationThreshold: this.options.adaptationThreshold\n        }\n      })\n      \n    } catch (error) {\n      logger.error('Failed to initialize Adaptive Storage augmentation:', error)\n      throw error\n    }\n  }\n\n  startMonitoring() {\n    this.monitoringTimer = setInterval(() => {\n      this.collectMetrics().catch(error => {\n        logger.warn('Metrics collection failed:', error)\n      })\n    }, this.options.monitoringInterval)\n  }\n\n  startOptimizations() {\n    // Cache optimization\n    this.cacheOptimizationTimer = setInterval(() => {\n      this.optimizeCache().catch(error => {\n        logger.warn('Cache optimization failed:', error)\n      })\n    }, this.options.cacheOptimizationInterval)\n    \n    // Storage optimization\n    this.storageOptimizationTimer = setInterval(() => {\n      this.optimizeStorage().catch(error => {\n        logger.warn('Storage optimization failed:', error)\n      })\n    }, this.options.storageOptimizationInterval)\n  }\n\n  async collectMetrics() {\n    const timestamp = Date.now()\n    \n    try {\n      // Memory metrics\n      const memoryUsage = process.memoryUsage()\n      this.metrics.memoryUsage.push({\n        timestamp,\n        heapUsed: memoryUsage.heapUsed,\n        heapTotal: memoryUsage.heapTotal,\n        external: memoryUsage.external,\n        utilization: memoryUsage.heapUsed / memoryUsage.heapTotal\n      })\n      \n      // Keep only recent metrics (last 30 readings)\n      if (this.metrics.memoryUsage.length > 30) {\n        this.metrics.memoryUsage = this.metrics.memoryUsage.slice(-30)\n      }\n      \n      // Trigger adaptations if needed\n      await this.checkAdaptationTriggers()\n      \n    } catch (error) {\n      logger.warn('Failed to collect some metrics:', error)\n    }\n  }\n\n  async checkAdaptationTriggers() {\n    const latestMemory = this.metrics.memoryUsage[this.metrics.memoryUsage.length - 1]\n    \n    if (!latestMemory) return\n    \n    // High memory usage adaptation\n    if (latestMemory.utilization > this.options.adaptationThreshold) {\n      await this.adaptToHighMemoryUsage(latestMemory)\n    }\n    \n    // Low memory usage optimization\n    if (latestMemory.utilization < 0.3 && this.capabilities.memory.available > 1000) {\n      await this.adaptToLowMemoryUsage(latestMemory)\n    }\n  }\n\n  async adaptToHighMemoryUsage(memoryMetrics) {\n    const adaptationId = `high-memory-${Date.now()}`\n    \n    logger.info('Adapting to high memory usage', {\n      utilization: (memoryMetrics.utilization * 100).toFixed(1) + '%',\n      heapUsed: Math.round(memoryMetrics.heapUsed / 1024 / 1024) + 'MB'\n    })\n    \n    const actions = []\n    \n    // Reduce cache size\n    if (this.db.cache && this.db.cache.setMaxSize) {\n      const currentMaxSize = this.db.cache.getMaxSize ? this.db.cache.getMaxSize() : 10000\n      const newMaxSize = Math.max(1000, Math.floor(currentMaxSize * 0.8))\n      this.db.cache.setMaxSize(newMaxSize)\n      actions.push(`Reduced cache size to ${newMaxSize}`)\n    }\n    \n    // Enable more aggressive garbage collection hints\n    if (global.gc) {\n      global.gc()\n      actions.push('Triggered garbage collection')\n    }\n    \n    // Suggest storage upgrade if memory consistently high\n    const recentHighUsage = this.metrics.memoryUsage\n      .slice(-10)\n      .filter(m => m.utilization > this.options.adaptationThreshold)\n      .length\n    \n    if (recentHighUsage > 7) {\n      actions.push('Recommended: Consider upgrading to persistent storage')\n      \n      // Log storage upgrade suggestion\n      logger.warn('Consider storage upgrade', {\n        reason: 'Consistently high memory usage detected',\n        recommendation: 'Use filesystem or S3 storage for better performance',\n        currentStorage: this.capabilities.storage.memory ? 'memory' : 'unknown'\n      })\n    }\n    \n    this.recordAdaptation(adaptationId, 'high-memory', actions)\n  }\n\n  async adaptToLowMemoryUsage(memoryMetrics) {\n    const adaptationId = `low-memory-${Date.now()}`\n    \n    logger.debug('Optimizing for low memory usage', {\n      utilization: (memoryMetrics.utilization * 100).toFixed(1) + '%',\n      available: Math.round((memoryMetrics.heapTotal - memoryMetrics.heapUsed) / 1024 / 1024) + 'MB'\n    })\n    \n    const actions = []\n    \n    // Increase cache size if we have room\n    if (this.db.cache && this.db.cache.setMaxSize) {\n      const currentMaxSize = this.db.cache.getMaxSize ? this.db.cache.getMaxSize() : 10000\n      const availableMemory = this.capabilities.memory.available\n      \n      if (availableMemory > 500) {\n        const newMaxSize = Math.min(100000, Math.floor(currentMaxSize * 1.2))\n        if (newMaxSize > currentMaxSize) {\n          this.db.cache.setMaxSize(newMaxSize)\n          actions.push(`Increased cache size to ${newMaxSize}`)\n        }\n      }\n    }\n    \n    if (actions.length > 0) {\n      this.recordAdaptation(adaptationId, 'low-memory', actions)\n    }\n  }\n\n  async optimizeCache() {\n    if (!this.db.cache) return\n    \n    logger.debug('Running cache optimization...')\n    \n    const actions = []\n    \n    try {\n      // Analyze cache performance\n      const cacheStats = this.db.cache.getStats ? this.db.cache.getStats() : {}\n      \n      if (cacheStats.hitRate !== undefined) {\n        this.metrics.cacheHitRate.push({\n          timestamp: Date.now(),\n          hitRate: cacheStats.hitRate\n        })\n        \n        // Keep only recent cache metrics\n        if (this.metrics.cacheHitRate.length > 20) {\n          this.metrics.cacheHitRate = this.metrics.cacheHitRate.slice(-20)\n        }\n        \n        // Optimize based on hit rate\n        if (cacheStats.hitRate < 0.5) {\n          // Low hit rate - cache might be too small or eviction too aggressive\n          if (this.capabilities.memory.available > 500) {\n            actions.push('Consider increasing cache size due to low hit rate')\n          }\n        } else if (cacheStats.hitRate > 0.9) {\n          // Very high hit rate - might be able to optimize\n          actions.push('Excellent cache performance detected')\n        }\n      }\n      \n      // Clean up expired entries if supported\n      if (this.db.cache.cleanup) {\n        this.db.cache.cleanup()\n        actions.push('Cleaned up expired cache entries')\n      }\n      \n    } catch (error) {\n      logger.warn('Cache optimization error:', error)\n    }\n    \n    if (actions.length > 0) {\n      this.recordAdaptation(`cache-opt-${Date.now()}`, 'cache-optimization', actions)\n    }\n  }\n\n  async optimizeStorage() {\n    logger.debug('Running storage optimization...')\n    \n    const actions = []\n    \n    try {\n      // Get storage statistics\n      const stats = await this.db.getStatistics()\n      \n      if (stats) {\n        // Analyze entity/relationship ratio\n        const entityCount = stats.nounCount || 0\n        const relationshipCount = stats.verbCount || 0\n        \n        if (entityCount > 1000 && this.capabilities.storage.memory && this.capabilities.storage.filesystem) {\n          actions.push('Consider switching to filesystem storage for better performance')\n        }\n        \n        if (relationshipCount > 10000 && this.capabilities.storage.s3 && this.capabilities.environment === 'production') {\n          actions.push('Consider S3 storage for scalability with large datasets')\n        }\n        \n        // Index optimization suggestions\n        if (entityCount > 5000) {\n          actions.push('Large dataset detected - ensure HNSW index is optimized')\n        }\n      }\n      \n    } catch (error) {\n      logger.warn('Storage optimization error:', error)\n    }\n    \n    if (actions.length > 0) {\n      this.recordAdaptation(`storage-opt-${Date.now()}`, 'storage-optimization', actions)\n    }\n  }\n\n  recordAdaptation(id, type, actions) {\n    const adaptation = {\n      id,\n      type,\n      timestamp: new Date().toISOString(),\n      actions,\n      environment: this.capabilities.environment,\n      memoryAtTime: this.metrics.memoryUsage[this.metrics.memoryUsage.length - 1]\n    }\n    \n    this.adaptations.push(adaptation)\n    \n    // Keep only recent adaptations (last 50)\n    if (this.adaptations.length > 50) {\n      this.adaptations = this.adaptations.slice(-50)\n    }\n    \n    logger.info('Storage adaptation applied', {\n      id,\n      type,\n      actions: actions.length\n    })\n  }\n\n  // Public API methods\n  getMetrics() {\n    return {\n      memory: this.metrics.memoryUsage.slice(-10), // Last 10 readings\n      cacheHitRate: this.metrics.cacheHitRate.slice(-10),\n      adaptations: this.adaptations.slice(-10),\n      summary: {\n        totalAdaptations: this.adaptations.length,\n        avgMemoryUtilization: this.calculateAverageMemoryUtilization(),\n        lastOptimization: this.adaptations[this.adaptations.length - 1]?.timestamp\n      }\n    }\n  }\n\n  calculateAverageMemoryUtilization() {\n    if (this.metrics.memoryUsage.length === 0) return 0\n    \n    const sum = this.metrics.memoryUsage.reduce((acc, m) => acc + m.utilization, 0)\n    return (sum / this.metrics.memoryUsage.length * 100).toFixed(1) + '%'\n  }\n\n  getRecommendations() {\n    const recommendations = []\n    \n    // Memory recommendations\n    const avgUtilization = this.calculateAverageMemoryUtilization()\n    const utilizationNum = parseFloat(avgUtilization)\n    \n    if (utilizationNum > 80) {\n      recommendations.push({\n        type: 'memory',\n        priority: 'high',\n        title: 'High memory usage detected',\n        description: `Average utilization: ${avgUtilization}`,\n        action: 'Consider upgrading to persistent storage or increasing memory limits'\n      })\n    }\n    \n    // Storage recommendations based on environment\n    if (this.capabilities.environment === 'production' && this.capabilities.storage.memory) {\n      recommendations.push({\n        type: 'storage',\n        priority: 'medium',\n        title: 'Production environment using memory storage',\n        description: 'Memory storage is not persistent across restarts',\n        action: 'Configure filesystem or S3 storage for production use'\n      })\n    }\n    \n    return recommendations\n  }\n\n  async cleanup() {\n    if (this.monitoringTimer) {\n      clearInterval(this.monitoringTimer)\n    }\n    \n    if (this.cacheOptimizationTimer) {\n      clearInterval(this.cacheOptimizationTimer)\n    }\n    \n    if (this.storageOptimizationTimer) {\n      clearInterval(this.storageOptimizationTimer)\n    }\n    \n    logger.info('Adaptive Storage augmentation cleaned up')\n  }\n}